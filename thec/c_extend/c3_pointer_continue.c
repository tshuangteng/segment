#include <stdio.h>

// 指针的加减运算

int main() {
    // 每一组的字节数相同来确保 内存中的对齐.
    // 延伸: 如果中间的一组字节数比较大, 则应该是从中间开始向2边对齐.
    typedef struct Info {
        char *name;  // 第一组: 8字节(*表示指针类型8字节, 也是该结构体中最大字节单位)
        // char name[7];
        int age; // 第二组: 8字节 以最大字节数表示
        double height;  // 第三组: 8字节 以最大字节的单位
        short hobby[3];  // 第四组: 8字节 以最大字节的单位
    } info;

    // int info_size = sizeof(struct Info);
    // printf("size of Info: %d\n", info_size);  // 该数据结构的字节数大小为32

    info ht;
    ht.age = 18;  // 内存中十进制数18的16进制为12
    ht.height = 178;  // 浮点数转换为16进制: Double双精度 (float64) ---> 40664000 00000000

    // 大字节类型 向 小字节类型 转换 , 导致内存溢出，或者精度问题
    // double *tp1 = (double *) ((char)&ht + 8);  // 强制转换类型, &ht表示指针类型(64位系统8字节) 转换为 char类型(1字节) 导致数据丢失.
    // printf("*tp1 = %f", *tp1);

    // ht数组名表示数组首元素的地址，是指针常量
    double *tp2 = (double *) ((int) &ht + 8);  // 指针常量 强制转换为普通的int数值, 内存中是以16进制(16字节)来表示计算的, 接着加数值8也就是8字节, 才能移动到该数组中的第二个元素.
    double *tp3 = (double *) ((char *) &ht + 16);  // 指针常量 强制转换为char类型的指针, 加16表示 移动16个sizeof(char)单位, 才能移动到该数组的第三个元素.
    int *tp33 = (int *) ((char *) &ht + 24);
    double *tp4 = (double *) ((int *) &ht + 2); // 指针常量 强制转换为int类型的指针, 加2表示 移动2个sizeof(int)单位, 才能移动到该数组的第二个元素.

    printf("*tp2 = %d\n", *tp2);  // *tp2 = 18
    printf("*tp3 = %f\n", *tp3);  // *tp3 = 178.000000
    printf("*tp33 = %x\n", *tp33);  // *tp33 = 401519
    printf("*tp4 = %d\n", *tp4);  // *tp4 = 18

    // 内存中存储如下
    // 0x000000000061fde0 00 00 00 00   00 00 00 00   12 00 00 00   00 00 00 00  // tp2和tp4 ---> 12 00 00 00   00 00 00 00
    // 0x000000000061fdf0 00 00 00 00   00 40 66 40   19 15 40 00   00 00 00 00  // tp3 ---> 00 00 00 00   00 40 66 40  tp33 ---> 19 15 40 00

    // 0x000000000061fe00 08 00 00 00   00 00 00 00   e8 fd 61 00   00 00 00 00  // &tp4 ---> e8 fd 61 00   00 00 00 00
    // 0x000000000061fe10 f0 fd 61 00   00 00 00 00   e8 fd 61 00   00 00 00 00  // &tp3 ---> f0 fd 61 00   00 00 00 00  &tp2 ---> e8 fd 61 00   00 00 00 00


    /*
     总结：指针移动的目的是为了去访问内存地址。
     而内存地址抽象出来的就是数字，所以进行指针访问时，需要移动指针其实就是对内存地址的数值进行加减运算，使指针针指向需要访问数据的内存空间的头位置处
     然后通过强制类型转换（类型匹配时不用强制类型转换），使用想要的解析方法去读取该内存空间的内容。
     */

    return 0;
}