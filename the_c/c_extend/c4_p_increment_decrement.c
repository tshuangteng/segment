#include<stdio.h>

/*
 指针的自增自减:
 在非内置类型的时候，尽量使用前置++ 效率高（后置自增，效率低）
 危险操作: 自减后的指向不可预测，因为可能占用了系统正常运行所需要的内存，有可能导致系统瘫痪

 数组名指针:
 指针是地址变量，而数组名代表数组的首地址，是指针常量。
 数组名在运算中可以作为指针参与，但不允许被赋值，指针可变，允许指向别的位置,因为数组元素的指针就是数组元素的地址.
 */


int main() {
    /* ---------- */
    char a[] = "hello world";
    char *p = a;  // 定义指针变量p
    //    指针和数组常见等价操作 ---> 指针操作 数组操作 说明
    //    p  <--->  &a[0] 数组首地址
    //    p+i  <--->  &a[i] 数组的第i个元素的地址

    //    *p  <--->  a[0] 数组的第一个元素
    //    *(p+i)  <--->  a[i] 数组的第i个元素
    //    *p+b  <--->  a[0]+b 数组的第一个元素的值加b
    //    *(p+i)+b  <--->  a[i]+b 数组的第i个元素的值加b



    /* ---------- */
    int arr[] = {11, 12, 13, 14, 15};
    int *ptr = arr;  // *ptr是一级指针, arr数组名表示的是数组的首地址(arr[0]), 即是指针常量且指向的是int类型的数组arr.
    *(ptr++) += 100;  // ++在后, 先用+= 即可理解为*ptr += 100, *ptr是取该地址对应的内容,也就是普通数值的运算arr[0] + 100; 然后++是指针运算, 表示移动一个int类型的字节数指向到arr[1]
    printf("%d\n", arr[0]);  // 结果: 111
    printf("%d %d\n", *ptr, *(++ptr));  // printf输出的两个参数压栈顺序为从右至左，故也先计算*(++ptr). 结果: 13 13



    /* ---------- */
    // **p ---> 指针数组的引用可以认为是一个指向指针的指针. 因为数组名本身代表地址,可以当做指针参与运算(不能改变指针常量的值)加减位移出数组元素值的指针
    // c/c++中, 输出字符指针(指针指向的内容是字符)就是输出字符串,程序会自动在遇到\0后停止

    char *ta[2] = {"one", "two"};  // 指针数组结构: ta中的元素都是指向char值的指针,存储的地方是{"one", "two"}中各单词首字母地址.
    char **tp = ta;  // 定义和初始化tp, tp是指向指针的指针
    // **tp中的tp是为二级指针 ---> 因为在一级指针*tp中,tp的地址是{"one", "two"}的首地址,则*tp的内容是"one\0". 所以二级指针**tp中,tp的地址是"one\0"的首地址,则**tp的内容是'o'
    printf("size of ta: %d\n\n", sizeof(ta));  // 占用字节数 即 2个指针在64位系统下所占的字节大小为16; one在前8字节, two在后8字节.


    printf("%s\t", (*tp + 1));  // 因为tp为二级指针, 故*tp指针指向的是ta[0]即char类型的"one\0". 接着, *tp+1表示移动1个sizeof(char)单位, 指向第二个字母'n', string结果: ne
    printf("%s\t", *(tp + 1));  // 数组名tp指针指向的是整个指针类型的数组, tp+1表示移动1个sizeof(指针)单位, 移到ta[1](也就是后8字节),t的位置处. string结果: two
    printf("%c\t", **tp);  // 原因在上已分析  char结果: o
    printf("%s\t", *(tp++) + 1);  // tp++中++后置的话,表示先用tp. 则首先是 *tp+1 移动到字符'n'的地址. string结果: ne
    printf("%c\n", **tp - 1);   // 上面,指针进行了自加tp++, 故指针tp指向"two", 则**tp表示取地址对应的的内容为t, 然后再执行普通运算 t-1. char结果: s

    printf("%s\t", *(--tp) + 1);  // 接着, 指针运算--在前先运算,向后移动1个指针字节单位,tp移动到了"one\0"的位置,然后执行*tp+1,到'n'. string结果: ne
    printf("%s\t", *(++tp) + 1);  // 接着运算, 思路参上,先移动到后8字节,tp移动到了字符't'的位置, 然后再执行加1字节, 到'w'. string结果: wo
    printf("%c\t", **tp);  // 接着, 因为此时tp在字符't'的位置, **tp是二级指针指向的内容, 因为*tp的值是"two\0"的首地址, 所以**tp的内容是't'. char结果: t
    printf("%c\t", **(tp--));  // 接着, --在后,先用, 故同上. char结果: t
    printf("%s\n", *tp);  // 接着, 先接着执行上面未完成的--, tp移动到了"one\0"的位置, 所以*tp的内容是'one'. string结果: one

    // char型指针数组的应用理解

    // 1. 二维数组的引用有可能会用到二级指针，遍历数组的元素等常规操作；字符串数组的应用。
    // 2. 一级指针的加减 必须对应相应的数组类型，最好的就是像引用数组那样应用。
    // 3. 二级指针可以用常规类型的数据类型来定义，但其加减并无实际意义.

    /* 参数传递应用理解

     当用变量名作为函数参数传递时代表的是变量的值
     当用数组名作为函数参数传递时: 由于数组名代表的是数组元素地址，因此传递的值是地址，所以形参为指针变量。

     实参的数组名代表一个固定的地址，或者说是指针变量，但形参数组名并不是一个固定的地址，而是按指针变量处理。
     */

    return 0;
}